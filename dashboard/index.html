<!-- V2 -->
<!DOCTYPE html>
<html>
  <head>
    <base target="_top">
    <meta charset="UTF-8">
    <!-- CSP 정책 수정 - frame-ancestors를 HTTP 헤더로 이동시키고 필요한 스타일 소스 추가 -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' https://www.gstatic.com https://cdn.jsdelivr.net https://cdnjs.cloudflare.com https://*.googleusercontent.com; style-src 'self' https://cdn.jsdelivr.net https://cdnjs.cloudflare.com https://fonts.googleapis.com 'unsafe-inline'; script-src 'self' https://www.gstatic.com https://cdn.jsdelivr.net https://cdnjs.cloudflare.com https://html2canvas.hertzen.com 'unsafe-inline' 'unsafe-eval'; img-src 'self' data: blob:;">
    <title>배차 대시보드</title>
    <!-- Google Charts 라이브러리 로드 -->
    <script src="https://www.gstatic.com/charts/loader.js"></script>
    <!-- 부트스트랩 CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- 폰트어썸 CSS -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
      body {
        font-family: 'Noto Sans KR', Arial, sans-serif;
        background-color: #f8f9fa;
        padding: 20px;
      }
      .dashboard-title {
        color: #343a40;
        margin-bottom: 30px;
        border-bottom: 2px solid #dee2e6;
        padding-bottom: 10px;
      }
      .card {
        margin-bottom: 20px;
        box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);
        border: none;
        border-radius: 10px;
        overflow: hidden;
      }
      .card-header {
        background-color: #f1f3f5;
        font-weight: bold;
        color: #495057;
        border-bottom: 1px solid rgba(0,0,0,.125);
        padding: 0.75rem 1.25rem;
      }
      /* 차트 컨테이너 강제 크기 지정 */
      .chart-container {
        width: 100% !important;
        height: 300px !important;
        min-height: 300px;
        position: relative;
        overflow: visible !important; /* 툴팁이 잘리지 않도록 visible 설정 */
      }
      
      /* 차트 내부 요소 강제 크기 조정 */
      .chart-container > div {
        width: 100% !important;
        height: 100% !important;
        overflow: visible !important; /* 툴팁이 잘리지 않도록 visible 설정 */
      }
      .chart-container svg {
        width: 100% !important;
        height: 100% !important;
        overflow: visible !important; /* 툴팁이 잘리지 않도록 visible 설정 */
      }
      
      /* 차트 툴팁 스타일 */
      .google-visualization-tooltip {
        z-index: 1000 !important;
        pointer-events: none !important;
        background-color: rgba(255, 255, 255, 0.95) !important;
        border: 1px solid #ccc !important;
        border-radius: 4px !important;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2) !important;
        padding: 8px !important;
        max-width: 300px !important;
        overflow: visible !important;
      }
      /* Google 차트 관련 요소 */
      .google-visualization-table-table {
        width: 100%;
      }
      .summary-value {
        font-size: 24px;
        font-weight: bold;
        color: #1e88e5;
      }
      .summary-label {
        color: #757575;
        font-size: 14px;
      }
      .loading {
        text-align: center;
        padding: 50px;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255, 255, 255, 0.9);
        border-radius: 8px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        z-index: 1000;
      }
      .table-responsive {
        overflow-x: auto;
      }
      .table th {
        background-color: #f1f3f5;
        position: sticky;
        top: 0;
        z-index: 10;
      }
      .sortable {
        cursor: pointer;
      }
      .sortable:hover {
        background-color: #e9ecef;
      }
      .mini-loader {
        display: inline-block;
        margin-left: 10px;
      }
      /* 메달 아이콘 스타일 */
      .medal-gold {
        color: gold;
        font-size: 1.2em;
        margin-right: 5px;
      }
      .medal-silver {
        color: silver;
        font-size: 1.2em;
        margin-right: 5px;
      }
      .medal-bronze {
        color: #CD7F32;
        font-size: 1.2em;
        margin-right: 5px;
      }
      /* 검색 필터 스타일 */
      #dispatcher-filter {
        width: 200px;
      }
      #clear-filter {
        cursor: pointer;
      }
      /* 새로고침 버튼 스타일 */
      #refreshButton {
        padding: 5px 15px;
        border-radius: 20px;
        transition: all 0.3s ease;
      }
      #refreshButton:hover {
        background-color: #0d6efd;
        color: white;
      }
      #refreshButton i {
        margin-right: 5px;
      }
      /* 테이블 정렬 아이콘 스타일 */
      .sortable i {
        margin-left: 5px;
        font-size: 0.85em;
        color: #adb5bd;
      }
      .fa-sort-up, .fa-sort-down {
        color: #0d6efd !important;
      }
      /* 모바일 최적화 */
      @media (max-width: 768px) {
        .card-body {
          padding: 0.75rem;
        }
        .chart-container {
          height: 250px;
        }
      }
      
      /* 담당자별 상세 통계 테이블 스타일 */
      #dispatcher-stats-table {
        border-collapse: collapse;
        width: 100%;
        table-layout: auto; /* 내용물에 맞게 자동 조정 */
      }
      
      #dispatcher-stats-table th {
        border: 1px solid #dee2e6; /* 헤더 셀에 실선 테두리 */
        padding: 8px;
        white-space: nowrap; /* 텍스트 줄바꿈 방지 */
      }
      
      #dispatcher-stats-table td {
        border-top: 1px solid #dee2e6; /* 상단 테두리는 실선 */
        border-bottom: 1px solid #dee2e6; /* 하단 테두리는 실선 */
        border-left: 1px dashed #dee2e6; /* 좌측 테두리는 점선 */
        border-right: 1px dashed #dee2e6; /* 우측 테두리는 점선 */
        padding: 8px;
        white-space: nowrap; /* 텍스트 줄바꿈 방지 */
      }
      
      /* 시프트 스타일 */
      .shift-op {
        background-color: #0d6efd; /* 파랑색 배경 */
        color: white; /* 흰색 글자 */
        padding: 2px 5px;
        border-radius: 3px;
      }
      
      .shift-mid {
        background-color: #198754; /* 초록색 배경 */
        color: white; /* 흰색 글자 */
        padding: 2px 5px;
        border-radius: 3px;
      }
      
      .shift-cl {
        background-color: #8B0000; /* 검붉은 배경 */
        color: white; /* 흰색 글자 */
        padding: 2px 5px;
        border-radius: 3px;
      }
      
      .shift-nt {
        background-color: #6f42c1; /* 보라색 배경 */
        color: white; /* 흰색 글자 */
        padding: 2px 5px;
        border-radius: 3px;
      }
      
      .shift-mc {
        background: linear-gradient(to right, #CD853F, #8B4513); /* 밝은 갈색 그라데이션 */
        color: white; /* 흰색 글자 */
        padding: 2px 5px;
        border-radius: 3px;
      }
      
      .shift-4 {
        color: yellow; /* 노란색 글자 */
      }
      
      /* 점수 및 목표 달성 스타일 */
      .score-high {
        font-weight: bold;
        color: #198754; /* 초록색 */
      }
      
      .score-medium {
        font-weight: bold;
        color: #fd7e14; /* 주황색 */
      }
      
      .score-low {
        font-weight: bold;
        color: #dc3545; /* 빨간색 */
      }
      
      .goal-achieved {
        font-weight: bold;
        color: #198754; /* 초록색 */
        background-color: rgba(25, 135, 84, 0.1); /* 연한 초록색 배경 */
        padding: 2px 5px;
        border-radius: 3px;
      }
      
      .goal-partial {
        font-weight: bold;
        color: #fd7e14; /* 주황색 */
        background-color: rgba(253, 126, 20, 0.1); /* 연한 주황색 배경 */
        padding: 2px 5px;
        border-radius: 3px;
      }
      
      .goal-failed {
        font-weight: bold;
        color: #dc3545; /* 빨간색 */
        background-color: rgba(220, 53, 69, 0.1); /* 연한 빨간색 배경 */
        padding: 2px 5px;
        border-radius: 3px;
      }
      
      /* 스파크라인 컨테이너 스타일 */
      .sparkline-container {
        display: inline-block;
        margin-left: 10px;
        vertical-align: middle;
      }
      
      /* 스파크라인 캔버스 스타일 */
      .sparkline-canvas {
        display: inline-block;
        vertical-align: middle;
      }
      
      /* 바 스파크라인 스타일 */
      .bar-sparkline {
        display: inline-block;
        width: 40px;
        height: 20px;
        margin-left: 10px;
        vertical-align: middle;
        background-color: #e9ecef;
        border-radius: 2px;
        overflow: hidden;
      }
      
      .bar-sparkline-fill {
        height: 100%;
        background-color: #0d6efd;
      }
    </style>
  </head>
  <body>
    <div class="container-fluid">
      <h1 class="dashboard-title">배차 실적 대시보드</h1>
      
      <!-- 로딩 표시 -->
      <div id="loading" class="loading" style="opacity: 0; transition: opacity 0.5s ease-in-out;">
        <div class="spinner-border text-primary" role="status">
          <span class="visually-hidden">로딩 중...</span>
        </div>
        <p class="mt-2">데이터를 불러오는 중입니다...</p>
      </div>
      
      <div class="mb-3">
        <button id="refreshButton" class="btn btn-outline-primary">
          <i class="fas fa-sync-alt"></i> 데이터 새로고침
        </button>
        <span class="ms-2 mini-loader" style="display: none;">
          <div class="spinner-border spinner-border-sm text-primary" role="status">
            <span class="visually-hidden">로딩 중...</span>
          </div>
        </span>
      </div>
      
      <div id="dashboard-content" style="display: none; transition: opacity 0.5s ease-in-out;">
        <div class="row">
          <!-- 요약 통계 카드 -->
          <div class="col-md-3 mb-4">
            <div class="card h-100">
              <div class="card-header">총 배차 건수</div>
              <div class="card-body d-flex align-items-center justify-content-center">
                <div class="text-center">
                  <div id="total-count" class="summary-value">-</div>
                  <div class="summary-label">Total Dispatches</div>
                </div>
              </div>
            </div>
          </div>
          
          <div class="col-md-3 mb-4">
            <div class="card h-100">
              <div class="card-header">시스템 배차 비율</div>
              <div class="card-body d-flex align-items-center justify-content-center">
                <div class="text-center">
                  <div id="system-dispatch-rate" class="summary-value">-</div>
                  <div class="summary-label">System Dispatch Rate</div>
                </div>
              </div>
            </div>
          </div>
          
          <div class="col-md-3 mb-4">
            <div class="card h-100">
              <div class="card-header">오퍼레이터 배차 비율</div>
              <div class="card-body d-flex align-items-center justify-content-center">
                <div class="text-center">
                  <div id="operator-dispatch-rate" class="summary-value">-</div>
                  <div class="summary-label">Operator Dispatch Rate</div>
                </div>
              </div>
            </div>
          </div>
          
          <div class="col-md-3 mb-4">
            <div class="card h-100">
              <div class="card-header">평균 지연 시간</div>
              <div class="card-body d-flex align-items-center justify-content-center">
                <div class="text-center">
                  <div id="avg-delay-time" class="summary-value">-</div>
                  <div class="summary-label">Average Delay Time (seconds)</div>
                </div>
              </div>
            </div>
          </div>
        </div>
        
        <div class="row">
          <!-- 배차 결과 분포 차트 -->
          <div class="col-md-6 mb-4">
            <div class="card h-100">
              <div class="card-header">배차 결과 분포</div>
              <div class="card-body">
                <div id="dispatch-result-chart" class="chart-container"></div>
              </div>
            </div>
          </div>
          
          <!-- 담당자별 실적 분포 차트 -->
          <div class="col-md-6 mb-4">
            <div class="card h-100">
              <div class="card-header">담당자별 실적 분포</div>
              <div class="card-body">
                <div id="dispatcher-chart" class="chart-container"></div>
              </div>
            </div>
          </div>
        </div>
        
        <div class="row">
          <!-- 시간대별 배차 건수 차트 -->
          <div class="col-md-6 mb-4">
            <div class="card h-100">
              <div class="card-header">시간대별 배차 건수</div>
              <div class="card-body">
                <div id="hourly-chart" class="chart-container"></div>
              </div>
            </div>
          </div>
          
          <!-- 지역별 배차 건수 차트 -->
          <div class="col-md-6 mb-4">
            <div class="card h-100">
              <div class="card-header">지역별 배차 건수</div>
              <div class="card-body">
                <div id="region-chart" class="chart-container"></div>
              </div>
            </div>
          </div>
        </div>
        
        <div class="row">
          <!-- 고성과자/저성과자 카드 -->
          <div class="col-md-6 mb-4">
            <div class="card">
              <div class="card-header">고성과자 Top 5</div>
              <div class="card-body table-responsive p-0" style="max-height: 300px;">
                <table id="top-performers-table" class="table table-striped table-hover mb-0">
                  <thead>
                    <tr>
                      <th>순위</th>
                      <th>담당자</th>
                      <th>총 건수</th>
                      <th data-tooltip="performance-formula" cursor="pointer" title="성과 점수 계산 공식: 총 점수(20%) + 오퍼레이터 배차 비중(50%) + 평균 소요시간 역수(30%)">총 점수(i)</th>
                      <th>오퍼레이터 배차</th>
                      <th>평균 소요시간</th>
                    </tr>
                  </thead>
                  <tbody id="top-performers-body">
                    <!-- 여기에 자바스크립트로 행이 추가됩니다 -->
                  </tbody>
                </table>
              </div>
            </div>
          </div>
          
          <div class="col-md-6 mb-4">
            <div class="card">
              <div class="card-header">저성과자 Bottom 5</div>
              <div class="card-body table-responsive p-0" style="max-height: 300px;">
                <table id="bottom-performers-table" class="table table-striped table-hover mb-0">
                  <thead>
                    <tr>
                      <th>순위</th>
                      <th>담당자</th>
                      <th>총 건수</th>
                      <th data-tooltip="performance-formula" cursor="pointer" title="성과 점수 계산 공식: 총 점수(20%) + 오퍼레이터 배차 비중(50%) + 평균 소요시간 역수(30%)">총 점수(i)</th>
                      <th>오퍼레이터 배차</th>
                      <th>평균 소요시간</th>
                    </tr>
                  </thead>
                  <tbody id="bottom-performers-body">
                    <!-- 여기에 자바스크립트로 행이 추가됩니다 -->
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        </div>
        
        <!-- 담당자별 상세 통계 테이블 -->
        <div class="row">
          <div class="col-12 mb-4">
            <div class="card">
              <div class="card-header py-3 d-flex justify-content-between align-items-center">
                <h6 class="m-0 font-weight-bold text-primary">담당자별 상세 통계</h6>
                <div>
                  <div class="input-group">
                    <input type="text" id="dispatcher-filter" class="form-control" placeholder="담당자 검색...">
                    <div class="input-group-append">
                      <button id="clear-filter" class="btn btn-outline-secondary" type="button">
                        <i class="fas fa-times"></i>
                      </button>
                      <button id="capture-table" class="btn btn-outline-primary" type="button" title="테이블 캡처">
                        <i class="fas fa-camera"></i>
                      </button>
                    </div>
                  </div>
                </div>
              </div>
              <div class="card-body">
                <div class="table-responsive">
                  <table id="dispatcher-stats-table" class="table table-striped table-hover text-center">
                    <thead class="text-center">
                      <tr>
                        <th class="sortable" data-sort="dispatcher">
                          담당자 <span class="sort-icon">⇅</span>
                        </th>
                        <th class="sortable" data-sort="workShift">
                          시프트 <span class="sort-icon">⇅</span>
                        </th>
                        <th class="sortable" data-sort="workHours">
                          WH <span class="sort-icon">⇅</span>
                        </th>
                        <th class="sortable" data-sort="total">
                          총 건수 <span class="sort-icon">⇅</span>
                        </th>
                        <th class="sortable" cursor="pointer" data-sort="score">
                          총 점수(i) <span class="sort-icon">⇅</span>
                        </th>
                        <th class="sortable" data-sort="operator">
                          오퍼레이터 배차 <span class="sort-icon">⇅</span>
                        </th>
                        <th class="sortable" data-sort="system">
                          시스템 배차 <span class="sort-icon">⇅</span>
                        </th>
                        <th class="sortable" data-sort="cantProcess">
                          처리 불가 <span class="sort-icon">⇅</span>
                        </th>
                        <th class="sortable" data-sort="avgTime">
                          평균 소요시간 <span class="sort-icon">⇅</span>
                        </th>
                        <th class="sortable" data-sort="goalAchievement">
                          목표 달성 <span class="sort-icon">⇅</span>
                        </th>
                        <!-- <th class="sortable" data-sort="normal">
                          정상 이동 중 <span class="sort-icon">⇅</span>
                        </th> -->
                        <!-- <th class="sortable" data-sort="other">
                          기타 <span class="sort-icon">⇅</span>
                        </th> -->
                      </tr>
                    </thead>
                    <tbody id="dispatcher-stats-body" class="text-center">
                      <!-- 여기에 자바스크립트로 행이 추가됩니다 -->
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- 부트스트랩 JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- html2canvas 라이브러리 추가 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js" 
            integrity="sha512-BNaRQnYJYiPSqHHDb58B0yaPfCu+Wgds8Gp/gU33kqBtgNS4tSPHuGibyoeqMV/TJlSKda6FXzoEyYGjTe+vXA==" 
            crossorigin="anonymous" 
            referrerpolicy="no-referrer"></script>
    
  <!-- 차트 및 데이터 처리 스크립트 -->
  <script>
    // Google Charts 라이브러리 로드
    google.charts.load('current', {'packages':['corechart', 'bar', 'table']});
    google.charts.setOnLoadCallback(initCharts);
    
    // 차트 초기화
    function initCharts() {
      // 데이터 로드 시작
      loadData();
    }
    
    // 데이터 새로고침 타이머
    let refreshTimer;
    
    // 데이터 로드 중 상태 추적
    let isLoading = false;
    
    // 차트 데이터 전역 저장
    let chartData = {
      dispatcherStats: null,
      summary: null,
      hourlyStats: null,
      resultStats: null,
      performers: null
    };
    
    // 서버에서 데이터 로드
    function loadData(showSpinner = true, forceWorkPerformanceRefresh = false) {
      if (isLoading) return; // 이미 로드 중이면 중복 요청 방지
      isLoading = true;
      
      // 로딩 표시 (비침습적으로)
      if (showSpinner) {
        document.getElementById('loading').style.opacity = '1';
        document.getElementById('loading').style.display = 'block';
      } else {
        // 작은 로딩 표시기 표시
        const miniLoaders = document.querySelectorAll('.mini-loader');
        miniLoaders.forEach(loader => {
          loader.style.display = 'inline-block';
        });
      }
      
      // 요청 개수 설정 (비동기 요청 수)
      let pendingRequests = 5;
      
      // 근무자 실적 데이터 강제 새로고침
      if (forceWorkPerformanceRefresh) {
        google.script.run
          .withSuccessHandler(() => {
            console.log('근무자 실적 데이터 강제 새로고침 완료');
          })
          .withFailureHandler((error) => {
            console.error('근무자 실적 데이터 강제 새로고침 오류:', error);
          })
          .forceRefreshWorkPerformanceData();
      }
      
      // 담당자별 통계 로드
      google.script.run
        .withSuccessHandler((stats) => {
          chartData.dispatcherStats = stats;
          displayDispatcherStats(stats);
          
          // 데이터 로드 완료 후 로딩 표시 숨기기
          if (--pendingRequests === 0) {
            hideLoading(showSpinner);
            isLoading = false;
          }
        })
        .withFailureHandler((error) => {
          handleError(error);
          if (--pendingRequests === 0) {
            hideLoading(showSpinner);
            isLoading = false;
          }
        })
        .getDispatcherStats();
      
      // 전체 요약 통계 로드
      google.script.run
        .withSuccessHandler((summary) => {
          chartData.summary = summary;
          displaySummary(summary);
          
          // 데이터 로드 완료 후 로딩 표시 숨기기
          if (--pendingRequests === 0) {
            hideLoading(showSpinner);
            isLoading = false;
          }
        })
        .withFailureHandler((error) => {
          handleError(error);
          if (--pendingRequests === 0) {
            hideLoading(showSpinner);
            isLoading = false;
          }
        })
        .getDispatchSummary();
      
      // 시간대별 통계 로드
      google.script.run
        .withSuccessHandler((hourlyStats) => {
          chartData.hourlyStats = hourlyStats;
          displayHourlyStats(hourlyStats);
          
          // 데이터 로드 완료 후 로딩 표시 숨기기
          if (--pendingRequests === 0) {
            hideLoading(showSpinner);
            isLoading = false;
          }
        })
        .withFailureHandler((error) => {
          handleError(error);
          if (--pendingRequests === 0) {
            hideLoading(showSpinner);
            isLoading = false;
          }
        })
        .getHourlyStats();
      
      // 배차 결과 통계 로드
      google.script.run
        .withSuccessHandler((resultStats) => {
          chartData.resultStats = resultStats;
          displayDispatchResultStats(resultStats);
          
          // 데이터 로드 완료 후 로딩 표시 숨기기
          if (--pendingRequests === 0) {
            hideLoading(showSpinner);
            isLoading = false;
          }
        })
        .withFailureHandler((error) => {
          handleError(error);
          if (--pendingRequests === 0) {
            hideLoading(showSpinner);
            isLoading = false;
          }
        })
        .getDispatchResultStats();
        
      // 고성과자/저성과자 통계 로드
      google.script.run
        .withSuccessHandler((performers) => {
          chartData.performers = performers;
          displayPerformers(performers);
          
          // 데이터 로드 완료 후 로딩 표시 숨기기
          if (--pendingRequests === 0) {
            hideLoading(showSpinner);
            isLoading = false;
          }
        })
        .withFailureHandler((error) => {
          handleError(error);
          if (--pendingRequests === 0) {
            hideLoading(showSpinner);
            isLoading = false;
          }
        })
        .getTopPerformers();
    }
    
    // 로딩 표시 숨기기 함수
    function hideLoading(wasSpinner) {
      if (wasSpinner) {
        document.getElementById('loading').style.opacity = '0';
        setTimeout(() => {
          document.getElementById('loading').style.display = 'none';
        }, 500);
      } else {
        // 작은 로딩 표시기 숨기기
        const miniLoaders = document.querySelectorAll('.mini-loader');
        miniLoaders.forEach(loader => {
          loader.style.display = 'none';
        });
      }
      
      // 대시보드 컨텐츠 표시
      document.getElementById('dashboard-content').style.display = 'block';
      setTimeout(() => {
        document.getElementById('dashboard-content').style.opacity = '1';
      }, 10);
      
      // 차트 크기 조정 및 다시 그리기
      fixChartDisplay();
      
      // 자동 새로고침 설정
      setupAutoRefresh();
    }
    
    // 담당자별 통계를 저장할 전역 변수
    let dispatcherStatsData = {};
    let currentSort = { column: 'total', direction: 'desc', clickCount: 0 };
    let filterText = '';
    
    // 담당자별 통계 표시
    function displayDispatcherStats(stats) {
      // 전역 변수에 데이터 저장
      dispatcherStatsData = stats;
      
      // 담당자 차트 데이터 생성
      const chartContainer = document.getElementById('dispatcher-chart');
      
      try {
        // DataTable 생성
        const dataTable = new google.visualization.DataTable();
        dataTable.addColumn('string', '담당자');
        dataTable.addColumn('number', '점수');
        dataTable.addColumn({type: 'string', role: 'tooltip', p: {html: true}});
        
        // 행 추가
        Object.keys(stats).forEach(dispatcher => {
          const score = stats[dispatcher].totalScore;
          const total = stats[dispatcher].total;
          const tooltip = `<div style="padding:10px;"><strong>${dispatcher}</strong><br>총 점수: ${score}<br>총 건수: ${total}</div>`;
          dataTable.addRow([dispatcher, score, tooltip]);
        });
        
        // 차트 옵션
        const options = {
          title: '담당자별 배차 점수',
          chartArea: {
            left: 50,
            top: 30,
            width: '80%',
            height: '75%'
          },
          legend: {position: 'none'},
          colors: ['#4285F4'],
          hAxis: {
            title: '담당자',
            slantedText: true,
            slantedTextAngle: 45
          },
          vAxis: {
            title: '점수',
            minValue: 0
          },
          width: '100%',
          height: '100%',
          tooltip: { isHtml: true }
        };
        
        // 차트 그리기
        const chart = new google.visualization.ColumnChart(chartContainer);
        chart.draw(dataTable, options);
        
        // 전역 함수 정의
        window.drawDispatcherChart = function() {
          try {
            chart.draw(dataTable, options);
          } catch(e) {
            console.error("Error drawing dispatcher chart:", e);
          }
        };
      
      } catch (e) {
        console.error("Error creating dispatcher chart:", e);
        chartContainer.innerHTML = '<div class="alert alert-warning">차트 로드 중 오류가 발생했습니다.</div>';
      }
      
      // 테이블 데이터 렌더링
      renderDispatcherTable();
      
      // 정렬 이벤트 리스너 설정
      setupSortListeners();
      
      // 필터 이벤트 리스너 설정
      setupFilterListeners();
    }
    
    // 데이터 필터링 및 정렬
    function filterAndSortData() {
      // 필터링
      let filteredData = [];
      
      for (const dispatcher in dispatcherStatsData) {
        if (filterText && !dispatcher.toLowerCase().includes(filterText.toLowerCase())) {
          continue;
        }
        
        filteredData.push({
          dispatcher,
          data: dispatcherStatsData[dispatcher]
        });
      }
      
      // 정렬
      filteredData.sort((a, b) => {
        let direction = currentSort.direction === 'asc' ? 1 : -1;
        
        // 정렬이 없는 경우 기본 순서 반환
        if (currentSort.direction === 'none') {
          return 0;
        }
        
        switch(currentSort.column) {
          case 'dispatcher':
            return direction * a.dispatcher.localeCompare(b.dispatcher);
          case 'total':
            return direction * (a.data.total - b.data.total);
          case 'score':
            return direction * (a.data.totalScore - b.data.totalScore);
          case 'system':
            return direction * (a.data.systemDispatch - b.data.systemDispatch);
          case 'operator':
            return direction * (a.data.operatorDispatch - b.data.operatorDispatch);
          case 'normal':
            return direction * (a.data.normalMoving - b.data.normalMoving);
          case 'cantProcess':
            return direction * (a.data.cantProcess - b.data.cantProcess);
          case 'other':
            return direction * (a.data.other - b.data.other);
          case 'avgTime':
            return direction * (a.data.avgTime - b.data.avgTime);
          case 'workShift':
            return direction * a.data.workShift.localeCompare(b.data.workShift);
          case 'workHours':
            return direction * (a.data.workHours - b.data.workHours);
          case 'goalAchievement':
            return direction * (a.data.goalAchievement - b.data.goalAchievement);
          default:
            return direction * (a.data.total - b.data.total);
        }
      });
      
      return filteredData;
    }
    
    // 담당자 통계 테이블 렌더링
    function renderDispatcherTable() {
      const tableBody = document.getElementById('dispatcher-stats-body');
      tableBody.innerHTML = '';
      
      // 데이터 필터링 및 정렬
      const filteredData = filterAndSortData();
      
      // 점수 범위 계산을 위한 최대/최소값 찾기
      let maxScore = 0;
      let minScore = Infinity;
      
      filteredData.forEach(({data: s}) => {
        if (s.totalScore > maxScore) maxScore = s.totalScore;
        if (s.totalScore < minScore) minScore = s.totalScore;
      });
      
      // 점수 범위 계산
      const scoreRange = maxScore - minScore;
      const highScoreThreshold = maxScore - (scoreRange * 0.3); // 상위 30%
      const lowScoreThreshold = minScore + (scoreRange * 0.3); // 하위 30%
      
      // 행 추가
      filteredData.forEach(({dispatcher, data: s}) => {
        const row = tableBody.insertRow();
        
        // 담당자 셀
        const dispatcherCell = row.insertCell(0);
        dispatcherCell.textContent = dispatcher;
        
        // 시프트 셀
        const shiftCell = row.insertCell(1);
        
        // 시프트에 따른 스타일 적용
        if (s.workShift) {
          let shiftText = s.workShift.toString();
          let shiftSpan = document.createElement('span');
          
          // M-4&C-4 시프트 처리 (최우선 적용)
          if (shiftText.includes('M-4&C') || shiftText.includes('M-4 & C') || shiftText.includes('M-4&C-4')) {
            shiftSpan.className = 'shift-mc';
            shiftSpan.textContent = shiftText; // 전체 텍스트를 그대로 표시
          } 
          // 다른 시프트 처리
          else {
            // 시프트 배경색 및 글자색 설정
            if (shiftText.includes('OP')) {
              shiftSpan.className = 'shift-op';
            } else if (shiftText.includes('MID')) {
              shiftSpan.className = 'shift-mid';
            } else if (shiftText.includes('CL')) {
              shiftSpan.className = 'shift-cl';
            } else if (shiftText.includes('NT')) {
              shiftSpan.className = 'shift-nt';
            }
            
            // -4가 포함된 경우 -4 부분만 노란색으로 변경
            if (shiftText.includes('-4')) {
              const parts = shiftText.split('-4');
              shiftSpan.innerHTML = parts[0] + '<span class="shift-4">-4</span>' + (parts[1] || '');
            } else {
              shiftSpan.textContent = shiftText;
            }
          }
          
          shiftCell.appendChild(shiftSpan);
        }
        
        // 근무 시간 셀
        const workHoursCell = row.insertCell(2);
        // 8H인 경우 별 이모지 추가
        if (s.workHours && s.workHours.toString().includes('8')) {
          workHoursCell.innerHTML = s.workHours + ' ⭐';
        } else {
          workHoursCell.textContent = s.workHours;
        }
        
        // 총 건수 셀
        const totalCell = row.insertCell(3);
        totalCell.textContent = s.total;
        
        // 총 건수에 스파크라인 추가 (최근 5개 데이터 샘플 - 임의 데이터)
        if (s.timeSamples && s.timeSamples.length > 0) {
          const sparklineData = s.timeSamples.slice(0, Math.min(5, s.timeSamples.length));
          const sparklineContainer = document.createElement('span');
          sparklineContainer.className = 'sparkline-container';
          totalCell.appendChild(sparklineContainer);
          
          // 스파크라인 초기화를 위한 데이터 속성 추가
          sparklineContainer.setAttribute('data-sparkline', sparklineData.join(','));
          sparklineContainer.setAttribute('data-sparkline-type', 'line');
          sparklineContainer.setAttribute('data-sparkline-width', '50');
          sparklineContainer.setAttribute('data-sparkline-height', '20');
        }
        
        // 총 점수 셀
        const scoreCell = row.insertCell(4);
        const scoreSpan = document.createElement('span');
        
        // 점수에 따른 스타일 적용
        if (s.totalScore >= highScoreThreshold) {
          scoreSpan.className = 'score-high';
        } else if (s.totalScore <= lowScoreThreshold) {
          scoreSpan.className = 'score-low';
        } else {
          scoreSpan.className = 'score-medium';
        }
        
        scoreSpan.textContent = s.totalScore;
        scoreCell.appendChild(scoreSpan);
        
        // 오퍼레이터 배차 셀
        const opCell = row.insertCell(5);
        const opPercent = Math.round(s.operatorDispatch/s.total*100);
        
        // 오퍼레이터 배차 비율에 따른 색상 적용 (3단계 분류)
        const opPercentText = document.createElement('span');
        if (opPercent < 30) {
          // 30% 미만: 빨간색 (낮음)
          opPercentText.style.color = '#dc3545';
          opPercentText.style.fontWeight = 'bold';
        } else if (opPercent > 50) {
          // 50% 초과: 파란색 (높음)
          opPercentText.style.color = '#0d6efd';
          opPercentText.style.fontWeight = 'bold';
        } else {
          // 30~50%: 중간 값 - 회색
          opPercentText.style.color = '#6c757d';
        }
        opPercentText.textContent = `${s.operatorDispatch} (${opPercent}%)`;
        opCell.appendChild(opPercentText);
        
        // 오퍼레이터 배차 비율에 스파크라인 추가 (막대 그래프)
        const opSparklineContainer = document.createElement('span');
        opSparklineContainer.className = 'sparkline-container';
        opCell.appendChild(opSparklineContainer);
        
        // 스파크라인 초기화를 위한 데이터 속성 추가
        opSparklineContainer.setAttribute('data-sparkline', opPercent);
        opSparklineContainer.setAttribute('data-sparkline-type', 'bar');
        opSparklineContainer.setAttribute('data-sparkline-width', '40');
        opSparklineContainer.setAttribute('data-sparkline-height', '20');
        
        // 오퍼레이터 배차 비율에 따른 스파크라인 색상 설정
        let opSparklineColor;
        if (opPercent < 30) {
          opSparklineColor = '#dc3545'; // 빨간색 (낮음)
        } else if (opPercent > 50) {
          opSparklineColor = '#0d6efd'; // 파란색 (높음)
        } else {
          opSparklineColor = '#6c757d'; // 회색 (중간)
        }
        opSparklineContainer.setAttribute('data-sparkline-bar-color', opSparklineColor);
        
        // 시스템 배차 셀
        const sysCell = row.insertCell(6);
        const sysPercent = Math.round(s.systemDispatch/s.total*100);
        
        // 시스템 배차 비율에 따른 색상 적용 (3단계 분류)
        const sysPercentText = document.createElement('span');
        if (sysPercent > 45) {
          // 45% 초과: 빨간색 (높음)
          sysPercentText.style.color = '#dc3545';
          sysPercentText.style.fontWeight = 'bold';
        } else if (sysPercent < 30) {
          // 30% 미만: 톤다운된 초록색 (낮음)
          sysPercentText.style.color = '#2e7d32'; 
          sysPercentText.style.fontWeight = 'bold';
        } else {
          // 30~45%: 중간 값 - 회색
          sysPercentText.style.color = '#6c757d';
        }
        sysPercentText.textContent = `${s.systemDispatch} (${sysPercent}%)`;
        sysCell.appendChild(sysPercentText);
        
        // 시스템 배차 비율에 스파크라인 추가 (막대 그래프)
        const sysSparklineContainer = document.createElement('span');
        sysSparklineContainer.className = 'sparkline-container';
        sysCell.appendChild(sysSparklineContainer);
        
        // 스파크라인 초기화를 위한 데이터 속성 추가
        sysSparklineContainer.setAttribute('data-sparkline', sysPercent);
        sysSparklineContainer.setAttribute('data-sparkline-type', 'bar');
        sysSparklineContainer.setAttribute('data-sparkline-width', '40');
        sysSparklineContainer.setAttribute('data-sparkline-height', '20');
        
        // 시스템 배차 비율에 따른 스파크라인 색상 설정
        let sysSparklineColor;
        if (sysPercent > 45) {
          sysSparklineColor = '#dc3545'; // 빨간색 (높음)
        } else if (sysPercent < 30) {
          sysSparklineColor = '#2e7d32'; // 톤다운된 초록색 (낮음)
        } else {
          sysSparklineColor = '#6c757d'; // 회색 (중간)
        }
        sysSparklineContainer.setAttribute('data-sparkline-bar-color', sysSparklineColor);
        
        // 처리 불가 셀
        row.insertCell(7).textContent = s.cantProcess;
        
        // 평균 소요 시간 셀
        const avgTimeCell = row.insertCell(8);
        avgTimeCell.textContent = `${Math.round(s.avgTime)} 초`;
        
        // 평균 소요 시간에 스파크라인 추가 (라인 그래프)
        if (s.timeSamples && s.timeSamples.length > 0) {
          const timeSparklineContainer = document.createElement('span');
          timeSparklineContainer.className = 'sparkline-container';
          avgTimeCell.appendChild(timeSparklineContainer);
          
          // 스파크라인 초기화를 위한 데이터 속성 추가
          const timeData = s.timeSamples.slice(0, Math.min(10, s.timeSamples.length));
          timeSparklineContainer.setAttribute('data-sparkline', timeData.join(','));
          timeSparklineContainer.setAttribute('data-sparkline-type', 'line');
          timeSparklineContainer.setAttribute('data-sparkline-width', '50');
          timeSparklineContainer.setAttribute('data-sparkline-height', '20');
          timeSparklineContainer.setAttribute('data-sparkline-line-color', '#fd7e14');
        }
        
        // 목표 달성 셀
        const goalCell = row.insertCell(9);
        const goalSpan = document.createElement('span');
        
        // 목표 달성 여부에 따른 스타일 적용
        if (s.goalAchievement) {
          const goalText = s.goalAchievement.toString().toLowerCase();
          
          if (goalText.includes('달성') || goalText.includes('100%') || goalText.includes('완료')) {
            goalSpan.className = 'goal-achieved';
          } else if (goalText.includes('부분') || goalText.includes('진행') || 
                    (goalText.includes('%') && parseInt(goalText) >= 50)) {
            goalSpan.className = 'goal-partial';
          } else {
            goalSpan.className = 'goal-failed';
          }
          
          goalSpan.textContent = s.goalAchievement;
          goalCell.appendChild(goalSpan);
        } else {
          goalCell.textContent = s.goalAchievement;
        }
      });
      
      // 스파크라인 초기화
      initSparklines();
    }
    
    // 스파크라인 초기화 함수
    function initSparklines() {
      // 라인 스파크라인 그리기
      document.querySelectorAll('[data-sparkline-type="line"]').forEach(container => {
        const values = container.getAttribute('data-sparkline').split(',').map(Number);
        const width = parseInt(container.getAttribute('data-sparkline-width') || '50');
        const height = parseInt(container.getAttribute('data-sparkline-height') || '20');
        const lineColor = container.getAttribute('data-sparkline-line-color') || '#1e88e5';
        
        // 캔버스 생성
        const canvas = document.createElement('canvas');
        canvas.className = 'sparkline-canvas';
        canvas.width = width;
        canvas.height = height;
        container.appendChild(canvas);
        
        // 캔버스에 라인 그리기
        drawLineSparkline(canvas, values, lineColor);
      });
      
      // 바 스파크라인 그리기
      document.querySelectorAll('[data-sparkline-type="bar"]').forEach(container => {
        const value = parseInt(container.getAttribute('data-sparkline'));
        const barColor = container.getAttribute('data-sparkline-bar-color') || '#0d6efd';
        
        // 바 컨테이너 생성
        const barContainer = document.createElement('div');
        barContainer.className = 'bar-sparkline';
        container.appendChild(barContainer);
        
        // 바 채우기 요소 생성
        const barFill = document.createElement('div');
        barFill.className = 'bar-sparkline-fill';
        barFill.style.width = value + '%';
        barFill.style.backgroundColor = barColor;
        barFill.style.opacity = '1';
        barContainer.appendChild(barFill);
      });
    }
    
    // 라인 스파크라인 그리기 함수
    function drawLineSparkline(canvas, values, lineColor) {
      if (!values || values.length === 0) return;
      
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      
      // 캔버스 초기화
      ctx.clearRect(0, 0, width, height);
      
      // 데이터 정규화를 위한 최대/최소값 찾기
      const max = Math.max(...values);
      const min = Math.min(...values);
      const range = max - min || 1; // 0으로 나누기 방지
      
      // 라인 스타일 설정
      ctx.strokeStyle = lineColor;
      ctx.lineWidth = 1.5;
      ctx.lineCap = 'round';
      
      // 라인 그리기 시작
      ctx.beginPath();
      
      // 각 데이터 포인트를 캔버스에 그리기
      values.forEach((value, index) => {
        // x 좌표 계산 (데이터 포인트 간 균등 간격)
        const x = (index / (values.length - 1 || 1)) * width;
        
        // y 좌표 계산 (값 정규화)
        const normalizedValue = (value - min) / range;
        const y = height - (normalizedValue * (height - 4)) - 2; // 상하 2px 여백
        
        // 첫 포인트는 moveTo, 나머지는 lineTo
        if (index === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });
      
      // 라인 그리기
      ctx.stroke();
      
      // 시작점과 끝점에 점 표시
      const firstValue = (values[0] - min) / range;
      const lastValue = (values[values.length - 1] - min) / range;
      
      const firstY = height - (firstValue * (height - 4)) - 2;
      const lastY = height - (lastValue * (height - 4)) - 2;
      
      // 시작점
      ctx.beginPath();
      ctx.arc(0, firstY, 2, 0, Math.PI * 2);
      ctx.fillStyle = lineColor;
      ctx.fill();
      
      // 끝점
      ctx.beginPath();
      ctx.arc(width, lastY, 2, 0, Math.PI * 2);
      ctx.fillStyle = lineColor;
      ctx.fill();
    }
    
    // 정렬 이벤트 리스너 설정
    function setupSortListeners() {
      const headers = document.querySelectorAll('.sortable');
      
      headers.forEach(header => {
        header.style.cursor = 'pointer';
        
        // 초기 상태의 정렬 표시
        if (header.getAttribute('data-sort') === currentSort.column) {
          const icon = header.querySelector('span.sort-icon');
          if (currentSort.direction === 'asc') {
            icon.textContent = '⇧';
          } else if (currentSort.direction === 'desc') {
            icon.textContent = '⇩';
          } else {
            icon.textContent = '⇅';
          }
        }
        
        header.addEventListener('click', () => {
          const column = header.getAttribute('data-sort');
          
          // 정렬 방향 토글
          if (currentSort.column === column) {
            // 같은 열 클릭 시: 내림차순 -> 오름차순 -> 정렬 종료 -> 내림차순 순으로 변경
            currentSort.clickCount = (currentSort.clickCount + 1) % 3;
            
            if (currentSort.clickCount === 0) {
              // 내림차순
              currentSort.direction = 'desc';
            } else if (currentSort.clickCount === 1) {
              // 오름차순
              currentSort.direction = 'asc';
            } else {
              // 정렬 종료 (기본 정렬로 돌아감)
              currentSort.direction = 'none';
            }
          } else {
            // 새로운 열 선택 시 항상 내림차순으로 시작
            currentSort.column = column;
            currentSort.direction = 'desc';
            currentSort.clickCount = 0; // 내림차순 상태
          }
          
          // 모든 헤더의 아이콘 초기화
          headers.forEach(h => {
            h.querySelector('span.sort-icon').textContent = '⇅';
          });
          
          // 선택된 헤더의 아이콘 업데이트
          const icon = header.querySelector('span.sort-icon');
          if (currentSort.direction === 'asc') {
            // 오름차순
            icon.textContent = '⇧';
          } else if (currentSort.direction === 'desc') {
            // 내림차순
            icon.textContent = '⇩';
          } else {
            // 정렬 없음
            icon.textContent = '⇅';
          }
          
          // 테이블 다시 렌더링
          renderDispatcherTable();
        });
      });
    }
    
    // 필터 이벤트 리스너 설정
    function setupFilterListeners() {
      const filterInput = document.getElementById('dispatcher-filter');
      const clearButton = document.getElementById('clear-filter');
      
      filterInput.addEventListener('input', () => {
        filterText = filterInput.value;
        renderDispatcherTable();
      });
      
      clearButton.addEventListener('click', () => {
        filterInput.value = '';
        filterText = '';
        renderDispatcherTable();
      });
    }
    
      
    // 테이블 캡처 기능 설정
    function setupCaptureButton() {
      const captureButton = document.getElementById('capture-table');
      const statsTable = document.getElementById('dispatcher-stats-table');
      
      captureButton.addEventListener('click', async () => {
        try {
          // 로딩 표시
          const loadingDiv = document.createElement('div');
          loadingDiv.className = 'position-fixed top-0 start-0 w-100 h-100 d-flex justify-content-center align-items-center bg-dark bg-opacity-50';
          loadingDiv.style.zIndex = '9999';
          loadingDiv.innerHTML = '<div class="spinner-border text-light" role="status"><span class="visually-hidden">캡처 중...</span></div>';
          document.body.appendChild(loadingDiv);
          
          // 캡처 전 스파크라인 색상 강제 적용
          const sparklineCanvases = statsTable.querySelectorAll('canvas');
          sparklineCanvases.forEach(canvas => {
            // 캔버스 데이터 저장
            const imageData = canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);
            // 캔버스 다시 그리기 (색상 강제 적용)
            canvas.getContext('2d').putImageData(imageData, 0, 0);
          });
          
          // 바 스파크라인 색상 강제 적용
          const barSparklines = statsTable.querySelectorAll('.bar-sparkline-fill');
          barSparklines.forEach(bar => {
            // 원래 색상 가져오기
            const originalColor = bar.style.backgroundColor;
            // 색상 강제 적용을 위해 다시 설정
            bar.style.cssText = `width: ${bar.style.width}; background-color: ${originalColor} !important; opacity: 1 !important;`;
          });
          
          // 테이블 캡처
          const canvas = await html2canvas(statsTable, {
            backgroundColor: '#ffffff',
            scale: 2, // 고해상도로 캡처
            logging: false,
            useCORS: true,
            allowTaint: true,
            onclone: function(clonedDoc) {
              // 클론된 문서에서 스파크라인 캔버스 찾기
              const clonedSparklines = clonedDoc.querySelectorAll('canvas');
              
              // 원본 캔버스에서 클론된 캔버스로 이미지 데이터 복사
              sparklineCanvases.forEach((originalCanvas, index) => {
                if (index < clonedSparklines.length) {
                  const clonedCanvas = clonedSparklines[index];
                  const originalCtx = originalCanvas.getContext('2d');
                  const clonedCtx = clonedCanvas.getContext('2d');
                  
                  // 원본 캔버스의 이미지 데이터 가져오기
                  const imageData = originalCtx.getImageData(0, 0, originalCanvas.width, originalCanvas.height);
                  
                  // 클론된 캔버스에 이미지 데이터 복사
                  clonedCtx.putImageData(imageData, 0, 0);
                }
              });
              
              // 클론된 문서에서 바 스파크라인 찾기
              const clonedBarSparklines = clonedDoc.querySelectorAll('.bar-sparkline-fill');
              
              // 원본 바 스파크라인에서 클론된 바 스파크라인으로 스타일 복사
              barSparklines.forEach((originalBar, index) => {
                if (index < clonedBarSparklines.length) {
                  const clonedBar = clonedBarSparklines[index];
                  // 원본 바의 배경색 가져와서 클론에 적용
                  clonedBar.style.cssText = `width: ${clonedBar.style.width}; background-color: ${originalBar.style.backgroundColor} !important; opacity: 1 !important;`;
                }
              });
            }
          });
          
          // 캔버스를 이미지로 변환
          const imageData = canvas.toDataURL('image/png');
          
          // 클립보드에 복사
          try {
            // 새로운 방식으로 클립보드에 복사 시도
            const img = new Image();
            img.src = imageData;
            
            // 이미지가 로드될 때까지 기다림
            await new Promise((resolve, reject) => {
              img.onload = resolve;
              img.onerror = reject;
              // 이미지가 캐시된 경우를 대비해 타임아웃 설정
              setTimeout(resolve, 200);
            });
            
            // 임시 캔버스 생성
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = img.width;
            tempCanvas.height = img.height;
            
            // 이미지를 캔버스에 그림
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(img, 0, 0);
            
            // 클립보드에 복사 시도 (첫 번째 방법)
            tempCanvas.toBlob(async (blob) => {
              try {
                await navigator.clipboard.write([
                  new ClipboardItem({
                    [blob.type]: blob
                  })
                ]);
                console.log('클립보드 복사 성공 (방법 1)');
                alert('테이블이 클립보드에 복사되었습니다.');
              } catch (err) {
                console.error('클립보드 복사 방법 1 실패:', err);
                
                try {
                  // 두 번째 방법: 데이터 URL 직접 복사
                  const clipboardData = new ClipboardItem({
                    'image/png': blob
                  });
                  await navigator.clipboard.write([clipboardData]);
                  console.log('클립보드 복사 성공 (방법 2)');
                  alert('테이블이 클립보드에 복사되었습니다.');
                } catch (err2) {
                  console.error('클립보드 복사 방법 2 실패:', err2);
                  
                  // 세 번째 방법: 이미지 다운로드
                  const downloadLink = document.createElement('a');
                  downloadLink.href = imageData;
                  downloadLink.download = '담당자별_상세_통계_' + new Date().toISOString().slice(0, 10) + '.png';
                  document.body.appendChild(downloadLink);
                  downloadLink.click();
                  document.body.removeChild(downloadLink);
                  alert('클립보드 복사에 실패했습니다. 이미지가 다운로드됩니다.');
                }
              }
              
              // 로딩 표시 제거
              document.body.removeChild(loadingDiv);
            }, 'image/png');
          } catch (clipboardError) {
            console.error('클립보드 복사 전체 실패:', clipboardError);
            
            // 대체 방법: 이미지 다운로드
            const downloadLink = document.createElement('a');
            downloadLink.href = imageData;
            downloadLink.download = '담당자별_상세_통계_' + new Date().toISOString().slice(0, 10) + '.png';
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
            alert('클립보드 복사에 실패했습니다. 이미지가 다운로드됩니다.');
            
            // 로딩 표시가 남아있는 경우 제거
            const loadingElement = document.querySelector('.position-fixed.bg-dark.bg-opacity-50');
            if (loadingElement) {
              document.body.removeChild(loadingElement);
            }
          }
        } catch (error) {
          console.error('테이블 캡처 중 오류 발생:', error);
          alert('테이블 캡처 중 오류가 발생했습니다: ' + error.message);
          
          // 로딩 표시가 남아있는 경우 제거
          const loadingElement = document.querySelector('.position-fixed.bg-dark.bg-opacity-50');
          if (loadingElement) {
            document.body.removeChild(loadingElement);
          }
        }
      });
    }
    
    // 전체 요약 통계 표시
    function displaySummary(summary) {
      if (!summary) return;
      
      // 요약 카드 업데이트
      document.getElementById('total-count').textContent = summary.total;
      
      // 시스템 배차 비율 계산
      let systemCount = 0;
      if (summary.dispatchResults['시스템 배차']) {
        systemCount = summary.dispatchResults['시스템 배차'];
      }
      const systemRate = Math.round(systemCount / summary.total * 100);
      document.getElementById('system-dispatch-rate').textContent = `${systemRate}%`;
      
      // 오퍼레이터 배차 비율 계산
      let operatorCount = 0;
      if (summary.dispatchResults['오퍼레이터 배차']) {
        operatorCount = summary.dispatchResults['오퍼레이터 배차'];
      }
      const operatorRate = Math.round(operatorCount / summary.total * 100);
      document.getElementById('operator-dispatch-rate').textContent = `${operatorRate}%`;
      
      // 평균 지연 시간 표시
      document.getElementById('avg-delay-time').textContent = Math.round(summary.avgDelayTime);
      
      // 지역별 차트 데이터 생성
      const regionChartData = [['지역', '건수']];
      
      // 데이터 정렬 (건수 기준 내림차순)
      const sortedRegions = Object.keys(summary.regions)
        .map(region => ({ region, count: summary.regions[region] }))
        .sort((a, b) => b.count - a.count);
      
      sortedRegions.forEach(item => {
        regionChartData.push([`지역 ${item.region}`, item.count]);
      });
      
      // 지역별 차트 그리기 (분리된 함수 호출)
      displayRegionChart(regionChartData);
    }
    
    // 시간대별 통계 표시
    function displayHourlyStats(hourlyStats) {
      if (!hourlyStats || hourlyStats.length === 0) return;
      
      const chartContainer = document.getElementById('hourly-chart');
      
      try {
        // DataTable 생성
        const dataTable = new google.visualization.DataTable();
        dataTable.addColumn('string', '시간대');
        dataTable.addColumn('number', '건수');
        
        // 행 추가
        hourlyStats.forEach(stat => {
          dataTable.addRow([`${stat.hour}시`, stat.count]);
        });
        
        // 차트 옵션
        const options = {
          title: '시간대별 배차 건수',
          chartArea: {
            left: 50,
            top: 30,
            width: '80%',
            height: '75%'
          },
          legend: {position: 'none'},
          colors: ['#34A853'],
          hAxis: {
            title: '시간대',
            slantedText: false,
            showTextEvery: 1
          },
          vAxis: {
            title: '건수',
            minValue: 0
          },
          animation: {
            startup: true,
            duration: 1000,
            easing: 'out'
          },
          bar: {groupWidth: '70%'},
          width: '100%',
          height: '100%',
          tooltip: { isHtml: true }
        };
        
        // 차트 그리기
        const chart = new google.visualization.ColumnChart(chartContainer);
        chart.draw(dataTable, options);
        
        // 전역 함수 정의
        window.drawHourlyChart = function() {
          try {
            chart.draw(dataTable, options);
          } catch(e) {
            console.error("Error drawing hourly chart:", e);
          }
        };
      
      } catch (e) {
        console.error("Error creating hourly chart:", e);
        chartContainer.innerHTML = '<div class="alert alert-warning">차트 로드 중 오류가 발생했습니다.</div>';
      }
    }
    
    // 고성과자/저성과자 표시 함수
    function displayPerformers(performersData) {
      // 테이블 참조 가져오기
      const topTable = document.getElementById('top-performers-table');
      const bottomTable = document.getElementById('bottom-performers-table');
      
      // 테이블 본문 초기화
      const topBody = topTable.querySelector('tbody');
      const bottomBody = bottomTable.querySelector('tbody');
      
      // 기존 내용 모두 제거
      topBody.innerHTML = '';
      bottomBody.innerHTML = '';
      
      // Top 5 고성과자 표시
      performersData.top.forEach((performer, index) => {
        const row = topBody.insertRow();
        
        // 순위 셀 - 메달 이모지 추가
        const rankCell = row.insertCell(0);
        
        if (index < 3) {
          // 메달 이모지 (1-3위)
          const medalEmojis = ['🥇', '🥈', '🥉'];
          rankCell.innerHTML = `${medalEmojis[index]} ${index + 1}위`;
          rankCell.style.fontWeight = 'bold';
        } else {
          rankCell.textContent = `${index + 1}위`;
        }
        
        // 나머지 셀 추가
        row.insertCell(1).textContent = performer.dispatcher;
        
        // 총 건수 셀
        const totalCell = row.insertCell(2);
        totalCell.textContent = performer.total;
        
        // 총 건수에 스파크라인 추가
        const totalSparklineContainer = document.createElement('span');
        totalSparklineContainer.className = 'sparkline-container';
        totalCell.appendChild(totalSparklineContainer);
        
        // 임의의 데이터 생성 (실제 데이터가 있다면 그것을 사용)
        const totalData = Array.from({length: 5}, () => Math.floor(Math.random() * (performer.total * 0.5) + performer.total * 0.5));
        totalSparklineContainer.setAttribute('data-sparkline', totalData.join(','));
        totalSparklineContainer.setAttribute('data-sparkline-type', 'line');
        totalSparklineContainer.setAttribute('data-sparkline-width', '50');
        totalSparklineContainer.setAttribute('data-sparkline-height', '20');
        totalSparklineContainer.setAttribute('data-sparkline-line-color', '#0d6efd');
        
        // 총 점수 셀
        const scoreCell = row.insertCell(3);
        scoreCell.textContent = performer.totalScore;
        
        // 총 점수에 스파크라인 추가
        const scoreSparklineContainer = document.createElement('span');
        scoreSparklineContainer.className = 'sparkline-container';
        scoreCell.appendChild(scoreSparklineContainer);
        
        // 임의의 데이터 생성 (실제 데이터가 있다면 그것을 사용)
        const scoreData = Array.from({length: 5}, () => Math.floor(Math.random() * (performer.totalScore * 0.3) + performer.totalScore * 0.7));
        scoreSparklineContainer.setAttribute('data-sparkline', scoreData.join(','));
        scoreSparklineContainer.setAttribute('data-sparkline-type', 'line');
        scoreSparklineContainer.setAttribute('data-sparkline-width', '50');
        scoreSparklineContainer.setAttribute('data-sparkline-height', '20');
        scoreSparklineContainer.setAttribute('data-sparkline-line-color', '#198754');
        
        // 오퍼레이터 배차 셀
        const opCell = row.insertCell(4);
        const opPercent = Math.round(performer.operatorDispatch/performer.total*100);
        opCell.textContent = `${performer.operatorDispatch} (${opPercent}%)`;
        
        // 오퍼레이터 배차에 스파크라인 추가
        const opSparklineContainer = document.createElement('span');
        opSparklineContainer.className = 'sparkline-container';
        opCell.appendChild(opSparklineContainer);
        
        // 스파크라인 초기화를 위한 데이터 속성 추가
        opSparklineContainer.setAttribute('data-sparkline', opPercent);
        opSparklineContainer.setAttribute('data-sparkline-type', 'bar');
        opSparklineContainer.setAttribute('data-sparkline-width', '40');
        opSparklineContainer.setAttribute('data-sparkline-height', '20');
        
        // 오퍼레이터 배차 비율에 따른 스파크라인 색상 설정
        let opSparklineColor = '#6c757d'; // 기본 회색
        if (opPercent < 30) {
          const intensity = Math.max(30 - opPercent, 0) * 2.5;
          opSparklineColor = `rgb(${220 + intensity}, ${53 - intensity}, ${69 - intensity})`;
        } else if (opPercent > 70) {
          const intensity = Math.min(opPercent - 70, 30) * 2.5;
          opSparklineColor = `rgb(${13 - intensity}, ${110 + intensity}, ${253 + intensity})`;
        } else {
          const blueComponent = Math.round((opPercent - 30) / 40 * 255);
          const redComponent = Math.round((70 - opPercent) / 40 * 255);
          opSparklineColor = `rgb(${redComponent}, ${100}, ${blueComponent})`;
        }
        opSparklineContainer.setAttribute('data-sparkline-bar-color', opSparklineColor);
        
        // 평균 소요 시간 셀
        const avgTimeCell = row.insertCell(5);
        avgTimeCell.textContent = `${Math.round(performer.avgTime)} 초`;
        
        // 평균 소요 시간에 스파크라인 추가
        const timeSparklineContainer = document.createElement('span');
        timeSparklineContainer.className = 'sparkline-container';
        avgTimeCell.appendChild(timeSparklineContainer);
        
        // 임의의 데이터 생성 (실제 데이터가 있다면 그것을 사용)
        const timeData = Array.from({length: 5}, () => Math.floor(Math.random() * (performer.avgTime * 0.5) + performer.avgTime * 0.5));
        timeSparklineContainer.setAttribute('data-sparkline', timeData.join(','));
        timeSparklineContainer.setAttribute('data-sparkline-type', 'line');
        timeSparklineContainer.setAttribute('data-sparkline-width', '50');
        timeSparklineContainer.setAttribute('data-sparkline-height', '20');
        timeSparklineContainer.setAttribute('data-sparkline-line-color', '#fd7e14');
      });
      
      // Bottom 5 저성과자 표시
      bottomBody.innerHTML = '';
      
      performersData.bottom.forEach((performer, index) => {
        const row = bottomBody.insertRow();
        
        // 셀 추가
        row.insertCell(0).textContent = `${performersData.totalCount - index}위`;
        row.insertCell(1).textContent = performer.dispatcher;
        row.insertCell(2).textContent = performer.total;
        row.insertCell(3).textContent = performer.totalScore;
        row.insertCell(4).textContent = `${performer.operatorDispatch} (${Math.round(performer.operatorDispatch/performer.total*100)}%)`;
        row.insertCell(5).textContent = `${Math.round(performer.avgTime)} 초`;
      });
    }
    
    // 배차 결과 통계 표시
    function displayDispatchResultStats(resultStats) {
      if (!resultStats || resultStats.length === 0) return;
      
      const chartContainer = document.getElementById('dispatch-result-chart');
      
      try {
        // DataTable 생성
        const dataTable = new google.visualization.DataTable();
        dataTable.addColumn('string', '배차 결과');
        dataTable.addColumn('number', '건수');
        
        // 행 추가
        resultStats.forEach(stat => {
          dataTable.addRow([stat.result, stat.count]);
        });
        
        // 차트 옵션
        const options = {
          title: '배차 결과 분포',
          chartArea: {
            left: 30,
            top: 30,
            width: '60%',
            height: '75%'
          },
          pieHole: 0.4,
          colors: ['#4285F4', '#EA4335', '#FBBC05', '#34A853', '#8E24AA'],
          legend: {
            position: 'right',
            alignment: 'center',
            textStyle: {
              fontSize: 12
            }
          },
          tooltip: {
            showColorCode: true,
            text: 'both',
            isHtml: true
          },
          pieSliceText: 'value',
          width: '100%',
          height: '100%'
        };
        
        // 차트 그리기
        const chart = new google.visualization.PieChart(chartContainer);
        chart.draw(dataTable, options);
        
        // 전역 함수 정의
        window.drawResultChart = function() {
          try {
            chart.draw(dataTable, options);
          } catch(e) {
            console.error("Error drawing result chart:", e);
          }
        };
      
      } catch (e) {
        console.error("Error creating result chart:", e);
        chartContainer.innerHTML = '<div class="alert alert-warning">차트 로드 중 오류가 발생했습니다.</div>';
      }
    }
    
    // 전체 요약 통계 표시에서 지역별 차트 수정
    function displayRegionChart(regionData) {
      if (!regionData || regionData.length <= 1) return;
      
      const chartContainer = document.getElementById('region-chart');
      
      try {
        // 차트 데이터 변환
        const dataTable = google.visualization.arrayToDataTable(regionData);
        
        // 차트 옵션
        const options = {
          title: '지역별 배차 건수',
          chartArea: {
            left: 30,
            top: 30,
            width: '60%',
            height: '75%'
          },
          pieHole: 0.4,
          colors: ['#4285F4', '#EA4335', '#FBBC05', '#34A853', '#8E24AA', '#3949AB', '#039BE5', '#43A047'],
          legend: {
            position: 'right',
            alignment: 'center',
            textStyle: {
              fontSize: 12
            }
          },
          tooltip: {
            showColorCode: true,
            isHtml: true,
            trigger: 'selection'
          },
          pieSliceText: 'value',
          width: '100%',
          height: '100%'
        };
        
        // 차트 그리기
        const chart = new google.visualization.PieChart(chartContainer);
        chart.draw(dataTable, options);
        
        // 전역 함수 정의
        window.drawRegionChart = function() {
          try {
            chart.draw(dataTable, options);
          } catch(e) {
            console.error("Error drawing region chart:", e);
          }
        };
      
      } catch (e) {
        console.error("Error creating region chart:", e);
        chartContainer.innerHTML = '<div class="alert alert-warning">차트 로드 중 오류가 발생했습니다.</div>';
      }
    }
    
    // 오류 처리
    function handleError(error) {
      console.error('Error:', error);
      document.getElementById('loading').innerHTML = `
        <div class="alert alert-danger" role="alert">
          데이터를 로드하는 중 오류가 발생했습니다: ${error}
        </div>`;
      
      // 미니 로더 숨기기
      const miniLoaders = document.querySelectorAll('.mini-loader');
      miniLoaders.forEach(loader => {
        loader.style.display = 'none';
      });
      
      // 로딩 상태 해제
      isLoading = false;
    }
    
    // 차트 컨테이너 크기 설정 및 모든 차트 다시 그리기
    function fixChartDisplay() {
      // 모든 차트 컨테이너의 스타일 수정
      setChartContainersFullWidth();
      
      // 저장된 차트 다시 그리기 함수 호출
      if (typeof window.drawResultChart === 'function') window.drawResultChart();
      if (typeof window.drawRegionChart === 'function') window.drawRegionChart();
      if (typeof window.drawHourlyChart === 'function') window.drawHourlyChart();
      if (typeof window.drawDispatcherChart === 'function') window.drawDispatcherChart();
    }
    
    // 모든 차트 컨테이너에 공통 스타일 적용
    function setChartContainersFullWidth() {
      const chartContainers = document.querySelectorAll('.chart-container');
      
      chartContainers.forEach(container => {
        // 차트 컨테이너 스타일 설정
        container.style.width = '100%';
        container.style.height = '300px';
        container.style.position = 'relative';
        container.style.overflow = 'visible';
        
        // 차트가 로드된 후 내부 요소에도 스타일 적용
        const observer = new MutationObserver((mutations) => {
          const innerElements = container.querySelectorAll('div');
          innerElements.forEach(el => {
            el.style.width = '100%';
            el.style.height = '100%';
            el.style.overflow = 'visible';
          });
          
          // SVG 요소에도 스타일 적용
          const svgElements = container.querySelectorAll('svg');
          svgElements.forEach(svg => {
            svg.style.overflow = 'visible';
          });
        });
        
        observer.observe(container, { childList: true, subtree: true });
      });
    }
    
    // 자동 새로고침 설정
    function setupAutoRefresh() {
      // 이전 타이머 제거
      if (refreshTimer) {
        clearInterval(refreshTimer);
      }
      
      // 5분(300000밀리초)마다 데이터 새로고침 (로딩 스피너 없이)
      refreshTimer = setInterval(() => {
        loadData(false);
      }, 300000);
    }
    
    // 문서 로드 완료 시 이벤트 리스너 설정
    document.addEventListener('DOMContentLoaded', function() {
      // 데이터 로드
      loadData();
      
      // 차트 초기화
      initializeCharts();
      
      // 새로고침 버튼 이벤트 리스너
      document.getElementById('refreshButton').addEventListener('click', function() {
        loadData();
      });
      
      // 정렬 및 필터 이벤트 리스너 설정
      setupSortListeners();
      setupFilterListeners();
      
      // 캡처 버튼 이벤트 리스너 설정
      setupCaptureButton();
      
      // 차트 표시 수정 (지연 적용)
      setTimeout(function() {
        fixChartDisplay();
      }, 1000);
    });
    
    // 페이지 완전 로드 후 차트 다시 그리기
    window.addEventListener('load', function() {
      // 페이지 완전 로드 후 모든 차트 다시 그리기
      setTimeout(function() {
        console.log("Window fully loaded - fixing charts");
        fixChartDisplay();
      }, 1000);
    });
    
    // 차트 초기화 후 호출되는 함수
    function initializeCharts() {
      // 차트 컨테이너 크기 설정
      setChartContainersFullWidth();
      
      // 차트 툴팁 스타일 개선
      const styleElement = document.createElement('style');
      styleElement.textContent = `
        .google-visualization-tooltip {
          z-index: 1000 !important;
          pointer-events: none !important;
          background-color: rgba(255, 255, 255, 0.95) !important;
          border: 1px solid #ccc !important;
          border-radius: 4px !important;
          box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2) !important;
          padding: 8px !important;
          max-width: 300px !important;
          overflow: visible !important;
        }
        
        .chart-container {
          overflow: visible !important;
        }
        
        .chart-container > div {
          overflow: visible !important;
        }
        
        .chart-container svg {
          overflow: visible !important;
        }
      `;
      document.head.appendChild(styleElement);
      
      // 차트 리사이즈 이벤트 처리
      window.addEventListener('resize', function() {
        if (typeof window.drawDispatcherChart === 'function') window.drawDispatcherChart();
        if (typeof window.drawHourlyChart === 'function') window.drawHourlyChart();
        if (typeof window.drawDispatchResultChart === 'function') window.drawDispatchResultChart();
        if (typeof window.drawRegionChart === 'function') window.drawRegionChart();
      });
    }
  </script>
  </body>
</html>
